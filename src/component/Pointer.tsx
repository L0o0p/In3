/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/Pointer.glb 
*/

import { useRef } from 'react';
import { Group, Vector3 } from 'three';
import { useThree, useFrame } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei'
import { Mesh } from 'three';

interface ModelNodes {
  [name: string]: Mesh;
}


export const Pointer = (props: ModelNodes) => {
  const { nodes } = useGLTF('/Pointer.glb') as unknown as { nodes: ModelNodes };
  const { materials } = useGLTF('/Pointer.glb')
  const ref = useRef<Group>(null)
  const { viewport, camera, pointer } = useThree();


  useFrame(() => {
    const x = (pointer.x * viewport.width) / 2;
    const y = (pointer.y * viewport.height) / 2;
    if (ref.current) {
      ref.current.position.set(x, y, 0);
      console.log('ok')
      // 更新相机位置，使其基于鼠标位置轻微移动
      const cameraX = -pointer.x * 2; // 水平方向上的移动
      const cameraY = -pointer.y * 1; // 垂直方向上的移动
      const cameraZ = 5; // 维持相机在Z轴的位置，保持一定的视距
      camera.position.lerp(new Vector3(cameraX, cameraY, cameraZ), 0.1);
      camera.lookAt(new Vector3(0, 0, 0));
    }

  });
  return (
    <group {...props} dispose={null}
      ref={ref}
      scale={5}
      rotation={[Math.PI / 2, Math.PI + Math.PI / 9, Math.PI / 12]}
      position={[0, 0, 2]}
    >
      <mesh geometry={nodes.group2098783903.geometry} material={materials.mat16} />
    </group>
  )
}

useGLTF.preload('/Pointer.glb')
